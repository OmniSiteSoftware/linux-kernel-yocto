/*
 * Copyright 2022 Digi International, Inc.
 *
 * The code contained herein is licensed under the GNU General Public
 * License. You may obtain a copy of the GNU General Public License
 * Version 2 or later at the following locations:
 *
 * http://www.opensource.org/licenses/gpl-license.html
 * http://www.gnu.org/copyleft/gpl.html
 */

/dts-v1/;

//#include <dt-bindings/gpio/gpio.h>
#include <dt-bindings/input/input.h>
#include <dt-bindings/leds/common.h>
#include <dt-bindings/rtc/rtc-stm32.h>
#include "ccmp13.dtsi"
#include "stm32mp13xc.dtsi"
#include "stm32mp13-pinctrl.dtsi"

/ {
	model = "Digi International ConnectCore MP13 DVK.";
	compatible = "digi,ccmp13-dvk", "digi,ccmp13", "st,stm32mp133";
	digi,machine,name = "ccmp133-dvk";

	aliases {
		ethernet0 = &eth1;
		ethernet1 = &eth2;
		mmc1 = &sdmmc1; /* Micro SD */
		serial0 = &uart5;
		serial1 = &usart1;
		serial2 = &uart8;
		serial3 = &usart2;
	};

	chosen {
		#address-cells = <1>;
		#size-cells = <1>;
		ranges;
		stdout-path = "serial0:115200n8";
	};
};

&adc_1 {
	/* PA5 which is shared with MikroE PWM */
	pinctrl-names = "default";
	pinctrl-0 = <&ccmp13_adc1_pins>;
	vdda-supply = <&scmi_vdd_adc>;
	vref-supply = <&scmi_vdd_adc>;
	status = "okay";

	adc1: adc@0 {
		st,adc-channels = <2>;
		st,min-sample-time-nsecs = <5000>;
		status = "okay";
	};
};

&crc1 {
	status = "okay";
};

&dma1 {
	sram = <&dma_pool>;
};

&dma2 {
	sram = <&dma_pool>;
};

&dts {
	status = "okay";
};

/* 10/100/1000 Ethernet */
&eth1 {
	status = "disabled";
	pinctrl-0 = <&eth1_rmii_pins_a>;
	pinctrl-1 = <&eth1_rmii_sleep_pins_a>;
	pinctrl-names = "default", "sleep";
	phy-mode = "rmii";
	max-speed = <100>;
	phy-handle = <&phy0>;
	st,eth-ref-clk-sel = <1>;
	st,ext-phyclk = <1>;

	mdio1 {
		#address-cells = <1>;
		#size-cells = <0>;
		compatible = "snps,dwmac-mdio";

		phy0: ethernet-phy@0 {
			reg = <0>;
			compatible = "ethernet-phy-id0007.c0f0"; /* PHY ID for SMSC LAN8720Ai */
			smsc,disable-energy-detect;
		};
	};
};

&scmi_regu {
	scmi_vddcpu: voltd-vddcpu {
		voltd-name = "vddcpu";
		regulator-name = "vddcpu";
	};
	scmi_vdd: voltd-vdd {
		voltd-name = "vdd";
		regulator-name = "vdd";
	};
	scmi_vddcore: voltd-vddcore {
		voltd-name = "vddcore";
		regulator-name = "vddcore";
	};
	scmi_vdd_adc: voltd-vdd_adc {
		voltd-name = "vdd_adc";
		regulator-name = "vdd_adc";
	};
	scmi_vdd_usb: voltd-vdd_usb {
		voltd-name = "vdd_usb";
		regulator-name = "vdd_usb";
	};
	scmi_vdd_sd: voltd-vdd_sd {
		voltd-name = "vdd_sd";
		regulator-name = "vdd_sd";
	};
	scmi_v1v8_periph: voltd-v1v8_periph {
		voltd-name = "v1v8_periph";
		regulator-name = "v1v8_periph";
	};
	scmi_v3v3_sw: voltd-v3v3_sw {
		voltd-name = "v3v3_sw";
		regulator-name = "v3v3_sw";
	};
};

/* Console on UART5 */
&uart5 {
	pinctrl-names = "default", "sleep", "idle";
	pinctrl-0 = <&ccmp13_uart5_pins_a>;
	pinctrl-1 = <&ccmp13_uart5_sleep_pins_a>;
	pinctrl-2 = <&ccmp13_uart5_idle_pins_a>;
	/delete-property/dmas;
	/delete-property/dma-names;
	status = "okay";
};

&usbh_ehci {
	phys = <&usbphyc_port0>;
	status = "okay";
};

&usbphyc {
	status = "okay";
};

&usbphyc_port0 {
	phy-supply = <&scmi_vdd_usb>;
	st,current-boost-microamp = <1000>;
	st,decrease-hs-slew-rate;
	st,tune-hs-dc-level = <2>;
	st,enable-hs-rftime-reduction;
	st,trim-hs-current = <11>;
	st,trim-hs-impedance = <2>;
	st,tune-squelch-level = <1>;
	st,enable-hs-rx-gain-eq;
	st,no-hs-ftime-ctrl;
	st,no-lsfs-sc;

	/*
	 * Hack to keep hub active if wakeup source is enabled
	 * otherwise the hub will wakeup the port0 as soon as the v3v3_sw is disabled
	 */
	connector {
		compatible = "usb-a-connector";
		vbus-supply = <&scmi_v3v3_sw>;
	};
};

&pinctrl {
	ccmp13_adc1_pins: ccmp13_adc1-pins-0 {
		pins {
			pinmux = <STM32_PINMUX('A', 5, ANALOG)>; /* ADC1 in2 */
		};
	};

	ccmp13_uart5_pins_a: ccmp13_uart5-0 {
		pins1 {
			pinmux = <STM32_PINMUX('A', 0, AF8)>; /* UART5_TX */
			bias-disable;
			drive-push-pull;
			slew-rate = <0>;
		};
		pins2 {
			pinmux = <STM32_PINMUX('F', 13, AF8)>; /* UART5_RX */
			bias-disable;
		};
	};

	ccmp13_uart5_idle_pins_a: ccmp13_uart5-idle-0 {
		pins1 {
			pinmux = <STM32_PINMUX('A', 0, ANALOG)>; /* UART5_TX */
		};
		pins2 {
			pinmux = <STM32_PINMUX('F', 13, AF8)>; /* UART5_RX */
			bias-disable;
		};
	};

	ccmp13_uart5_sleep_pins_a: ccmp13_uart5-sleep-0 {
		pins {
			pinmux = <STM32_PINMUX('A', 0, ANALOG)>, /* UART5_TX */
				 <STM32_PINMUX('F', 13, ANALOG)>; /* UART5_RX */
		};
	};
};
